//************************************************************// Created by: Elliott Shanks, Will Tanna, and Himanshu Mehru// CSS430, Spring 2014// FInal Project: File System// Inode.java//*************************************************************import java.util.Vector;public class Inode {    private final static int iNodeSize = 32;       // fix to 32 bytes    private final static int directSize = 11;      // # direct pointers    public Vector<Inode> allInodes;                // Maintains all inode on memory, is shared among all threads    public int length;                             // file size in bytes    public short count;                            // # file-table entries pointing to this    public short flag;                             // 0 = unused, 1 = used, 2 = read, 3 = write, 4 = delete    public short direct[] = new short[directSize]; // direct pointers    public short indirect;                         // a indirect pointer    Inode( ) {                                     // a default constructor      length = 0;      count = 0;      flag = 1;      for ( int i = 0; i < directSize; i++ )         direct[i] = -1;      indirect = -1;    }    Inode( short iNumber ) {                       // retrieving inode from disk      if(iNumber < 0){          return;      }      int blockId = getBlockId(iNumber);      // Generate the offset for the block      int offset = (iNumber % 16) * iNodeSize;      // Create a byte array of data with the same size as a block      byte[] data = new byte[Disk.blockSize];      // Read from the disk the blockId and store the data from the disk into it      SysLib.rawread(blockId, data);      // Sets inode variables      length = SysLib.bytes2int(data, offset);      offset += 4;      count = SysLib.bytes2short(data, offset);      offset += 2;      flag = SysLib.bytes2short(data, offset);      offset += 2;      // Create new iNode object with new values      for(int i = 0; i < directSize; i++, offset += 2){          direct[i] = SysLib.bytes2short(data, offset);      }      indirect = SysLib.bytes2short(data, offset);    }    public void toDisk( short iNumber ) {                // save to disk as the i-th inode       // Check if iNumber is less than 0, if it is then we need to return       // because it's not an actual block number       if(iNumber < 0){        return;       }       // Grab the block that has the ID of iNumber      int blockId = getBlockId(iNumber);      // Generate the offset for the block      int offset = (iNumber % 16) * iNodeSize;      // Create a byte array of data with the same size as a block      byte[] data = new byte[Disk.blockSize];      // Sets inode variables      SysLib.int2bytes(length, data, offset);      offset += 4;      SysLib.short2bytes(count, data, offset);      offset += 2;      SysLib.short2bytes(flag, data, offset);      offset += 2;        // Fill the inode's direct array with the previous information      for(int i = 0; i < directSize; i++, offset += 2){          SysLib.short2bytes(direct[i], data, offset);      }      SysLib.short2bytes(indirect, data, offset);      offset += 2;      // write to disk      SysLib.rawwrite(blockId, data);    }    // Return the indirect block    public short getIndexBlockNumber(){       return indirect;    }    // Create and set an Index Block with the indirect block    public boolean setIndexBlock(short indexBlockNumber){        // Error check        if(indexBlockNumber < 0 || indirect == -1){            return false;        }        // Set the index block to the indirect        indirect = indexBlockNumber;        return true;    }    // FIne a block in the disk and return it    public short findTargetBlock(int offset){        // Error check to make sure we can find the target block        if(offset < 0){            return -1;        }        // Calcualte the offset/seek pointer by the blocksize to find        // the correct block        int targetBlock = offset / Disk.blockSize;        // If the block number is within the size of the directSize we can        // pull it directly from the direct array        if(targetBlock < directSize){            return direct[targetBlock];        }        else{            // If we can't find the block in the direct we will just return -1.            // After hours of testing we found that this could be the reason why            // we have a couple tests fail in the test. There is more information            // within the report on why we think so. But there should possibly            // be indirect logic here.            return -1;        }    }    // Set a block in the direct array    public boolean setBlock(int iNumber, short blockId){        // Make sure that the iNumber is greater than 0 because we only have        // positive number blocks.        if(iNumber < 0){            return false;        }        // Loop through the direct array until we find one that is empty        // set it and return true        for(int i = 0; i < directSize; i++){            if(direct[i] == -1){                direct[i] = blockId;                return true;            }        }        // Else the direct array is full so we need to store it in the indirect        SysLib.cout("About to setBlock into indirect");        // Error checking with indirect block        if(indirect == -1)            return false;        // Store the iNumber in teh indirect        indirect = (short)iNumber;        // Create a byte array of data that is the same size as the block		byte[] data = new byte[Disk.blockSize];        // Read the indirect block into the data        SysLib.rawread(indirect, data);        // Subtract iNumber and directSize to create a new offset        int temp = iNumber - directSize;        // If the data array and offset are less than 0, then write the        // indirect block to disk and return True		if (SysLib.bytes2short(data, temp * 2) < 0) {            SysLib.short2bytes(blockId, data, temp * 2);		    SysLib.rawwrite(indirect, data);            return true;		}        return false;    }    // Return the block ID with the given iNumber    public int getBlockId(int iNumber){       return 1 + iNumber / 16;    }}